/*

[알고리즘의 분석]

알고리즘의 자원(resource) 사용량을 분석

자원이란? 실행시간, 메모리 사용량, 저장장치 사용량, 통신량(패킷) 등
--> 여기서는 실행시간의 분석에 대해 다룸

*/


/*

[시간 복잡도 (time complexity)]

- 실제 실행시간은 실행 환경에 따라 달라짐: 하드웨어, 운영체제, 언어, 컴파일러 
--> 물리적인 시간으로 비교하는 것은 불가능
- 실행 시간을 측정하는 대신, "연산의 실행 횟수"를 카운트
- 연산의 실행 횟수는 "업력 데이터의 크기에 관한 함수"로 표현
- 데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐 --> 대표값을 측정:
    - 최악의 경우: worst-case analysis
    - 평균: average-case analysis (계산하기 어려움)

*/


/*

[점근적(Asymptotic) 분석]

점근적 표기법을 사용:
    - 데이터의 개수 n이 무한으로 갈 때, 수행시간이 증가하는 growth rate로 시간복잡도를 표현하는 기법
    e.g. n(n-1)/2 + 5  -->  O(n^2) or theta(n^2)

유일한 분석법도 아니고, 가장 좋은 분석법도 아님:
    - 다만 (상대적으로) 가장 간단하며
    - 알고리즘의 실행환경에 비의존적임
--> 따라서 가장 광법위하게 사용됨

*/


/*

[점근적 분석의 예: 상수 시간 복잡도]

입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 중 n/2번째 데이터를 반환한다.

int sample(ind data[], int n) {
    int k = n/2;
    return data[k];
}

Result: n 값에 관계없이 상수 시간이 소요된다. 시간복잡도는 O(1) 

*/


/*

[점근적 분석의 예: 선형 시간 복잡도]

e.g.1) 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 합을 구하여 반환한다.

int sum(int data[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        // 이 알고리즘에서 가장 자주 실행되는 statement로, 실행 횟수는 항상 n번이다.
        // 가장 자주 실행되는 문장의 실행 횟수가 n번이라면,
        // 모든 문장의 실행 횟수의 합은 n에 선형적으로 비례하며,
        // 모든 연산들의 실행횟수의 합도 역시 n에 선형적으로 비례한다.
        sum = sum + data[i];  
    }
    return sum;
}

Result: 선형 시간복잡도 O(n)


e.g.2) 순차탐색: 배열 data에 정수 target이 있는지 검사한다.

int search(int n, int data[], int target){
    for (int i = 0; i < n; i++) {
        if (data[i] == target) {
            return i;
        }
    return -1;
}

Result: 최악의 경우 O(n)

*/


/*

[Quadratic]

배열 x에 중복된 원소가 있는지 검사한다.

bool is_distinct(int n, int x[]) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (x[i] == x[j]) {  // 가장 많이 실행됨: n(n-1)/2번
                return false;
            }
        }
    }
    return true;
}

Result: 최악의 경우 배열에 저장된 모든 원소 쌍을 비교하므로, 비교 연산의 횟수는 n(n-1)/2이다.
--> O(n^2)

i = 0, j: 1 ~ (n-1) --> (n-1)회 비교
i = 1, j: 2 ~ (n-1) --> (n-2)회 비교
i = 2, j: 3 ~ (n-1) --> (n-3)회 비교
...
i = (n-2), j: (n-2) ~ (n-1) --> 1회 비교

--> 1 + ... + n-3 + n-2 + n-1 = (양 끝의 합) * (숫자의 개수) / 2
= (1 + n - 1) * ((1 + n - 1) - 1) / 2 = n(n-1)/2

*/


/*

for (i = 1; i < n; i *= 2) {
    // Do something   <-- 이 문장의 실행 횟수는?
}

A:  i >= n 이 될때까지, i는 2의 거듭제곱으로 증가 (1, 2, 4, 8, 16, ...)

루프가 k번 반복되었을 때 i = 2^(k-1)
다음 루프 검사시 i *= 2가 되어 i = 2^k가 되고, i = 2^k >= n으로 이때 거짓이 되며 빠져나감
--> 2^k >= n 을 만족하는 최소의 정수가 곧 반복실행 횟수임

k >= log2(n) --> k는 log2(n)보다 조금 크거나 같은 정수
*/
