#`%p`의 출력
  
```
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {

	int a = 10;
	char b = 'A';

	printf("%p\n", a);
	printf("%p\n", b);

	return 0;
}
```
위 코드 블럭의 실행 결과는 어떻게 되겠는가?
```
000000000000000A
0000000000000041
```

이렇게 나온다. 왜 그런지 한번 생각해보자.
위와 같이 `printf()`를 사용하는 것은 사실 undefined behavior(UB) 이다. `%p`는 포인터에 대한 conversion specifier로써,  
이에 대응되는 변수 또한 포인터 변수여야한다. 그러나, 위의 예시에선 각각 `int`형, `char`형 변수가 전달되었다. 이는 명백한 위반이다.  
  
이 경우엔 각 변수의 값을 그대로 16진수로 해석하여 출력했다.  
64비트 환경에서 하나의 포인터 변수가 차지하는 메모리 크기는 8바이트다. 8바이트는 64비트다.  
16진수는 말 그대로 문자 하나가 총 16개의 값을 나타낼 수 있다. 즉, $2^4$개의 수를 나타내며, 이는 한개의 16진수가 총 4비트를 표현할 수 있음을 의미한다.  
따라서 포인터 변수 하나를 16진수 문자열로 표현하기 위해선, 총 16개의 16진수가 필요한 것이다.  
이것이 위 결과에서 $0$으로 패딩하여 총 16자리가 표현된 이유이다. 


```
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {

	int a = 10;
	char b = 'A';

	printf("%p\n", &a);
	printf("%p\n", &b);

	return 0;
}
```

제대로 `&`연산자를 붙여 주소값을 출력해보면:
```
0000000F7D32FBB4
0000000F7D32FBD4
```
위와 같이 변수의 메모리 주소가 제대로 출력되는 것을 확인할 수 있다. 주소가 비슷해 보이는 건 실제로 두 변수가 가까이 위치(같은 스택 프레임)하기 때문인데, 이는 추후 다시 설명하겠다.  
참고로 `%p`는 사람이 읽기 편한 빅 엔디안(big-endian)의 형식으로 출력된다. 이또한 나중에 별도의 글에서 다루도록 하겠다.  
