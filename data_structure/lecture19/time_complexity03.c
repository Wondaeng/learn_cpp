/* 
[버블 정렬 (bubble sort)]

n개중 가장 큰 값을 가장 뒤로 옮기고,
n-1개중 가장 큰 값을 가장 뒤로 옮기고,
...
2개중 큰 값을 뒤로 옮기기

시간 복잡도:
(n - 1) + (n - 2) + ... + 2 + 1 = n(n - 1)/2 --> O(n^2)

항상 모든 데이터를 확인함 --> 최악 = 최선 = 평균 
*/

void bubbleSort(int data[], int n) {
	for (int i = n - 1; i > 0; i--) {
		for (int j = 0; j < i; j++) {  // j 는 0부터 i - 1 까지
			if (data[j] > data[j + 1]) { 
				int tmp = data[j];
				data[j] = data[j + 1];
				data[j + 1] = tmp;
			}
		}
	}
}


/*
[삽입 정렬 (insertion sort)]

삽입 연산: 어떤 배열의 데이터들이 이미 정렬되어 있을 때, 새로운 데이터 하나를
자기자리를 찾아서 올바른 위치에 삽입하는 연산

삽입 정렬: 삽입 연산을 반복적으로 수행하여 배열을 정렬하는 것

시간복잡도: 
최선 - O(n)
최악 - O(n^2): (n-1) + ... + 2 + 1

*/


void insertion_sort(int n, int data[]) {
	for (int i = 1; i < n; i++) {  // 0 ~ (i-1) 번쨰 데이터는 이미 정렬되어있음
		int tmp = data[i];
		int j = i - 1;
		while (j >= 0 && data[j] > tmp) {
			/*
			우리가 삽입하고 있는 숫자를 j를 감소시켜가며 비교하고,
			data[j]가 더 크다면 위치를 바꿔주는 연산임.
			우리가 삽입하려 하는 숫자는 항상 현재 비교대상이 되는 숫자(j)의 오른쪽(j+1)에 있음.
			따라서 별도의 변수에 저장해두지 않으면 아래 줄에 의해 잃어버리게 됨.
			*/
			data[j + 1] = data[j];  
			j--;
		}
		data[j + 1] = tmp;
	}
}


/*

[퀵소트 (quicksort) 알고리즘]
- 컴퓨터에서 가장 유명한 정렬 알고리즘을 꼽으라면 이거다
- 최악: O(n^2), 평균: O(n*log2(n))

최악의 경우에도 O(n*log2(n))를 가지는 알고리즘:
- 합병정렬 (merge sort)
- 힙 정렬 (heap sort)

만약 배열이 아닌 연결리스트에 데이터가 저장되어있다면?
--> 어떤 경우라도 O(n^2)를 벗어나기 힘들다.
*/
