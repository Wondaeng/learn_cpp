# 제 3장: 정렬 (sort)
## 다양한 정렬 알고리즘
| 정렬 알고리즘 | 특징 |
|---|---|
| • Bubble sort<br>• Insertion sort<br>• Selection sort | simple, slow |
| • Quicksort<br>• Merge sort<br>• Heap sort | fast |
| • Radix sort | O(N) |

## 기본적인 정렬 알고리즘
### 선택 정렬 (selection sort)
- 각 루프마다:
  - 최대 원소를 찾는다
  - 최대 원소와 맨 오른쪽 원소를 교환한다
  - 맨 오른쪽 원소를 (루프의 탐색 범위에서) 제외한다  
→ 하나의 원소만 남을 때까지 위의 루프를 반복

```
selectionSort(A[], n)
{
    for last <- n downto 2    {
        find max A[k] among A[1...last] // 가장 큰 수 A[k]를 찾는다;
        A[k] <-> A[last];  // 교환
    }
}
```
- for 루프는 총 $n-1$회 반복
- 각 루프마다 가장 큰 수를 찾기 위한 비교 횟수: $n-1, n-2, \cdots, 2, 1$
(last개의 수 중에서 최대값을 찾기 위해선 last-1번의 비교가 필요)
- 교환은 상수 작업
→ 시간 복잡도 $T(n) = (n-1) + (n-2) + \cdots + 2 + 1 = \frac{n(n-1)}{2} = O(n^2)$


- 어떤 입력에 대해서도 동일한 작업을 수행하기 때문에 최선, 최악, 평균의 경우를 구분할 필요가 없이 항상 동일한 시간복잡도를 가짐

### 버블 정렬 (bubble sort)
- 기본 아이디어는 selection sort와 유사함: 정렬할 데이터 중에서 가장 큰 값을 찾아 맨 마지막 자리로 옮긴 뒤, 그 데이터는 제외하고 같은 작업을 계속 반복
- **다만,** 최댓값을 찾고 이를 마지막 요소로 만드는 세부적인 방법이 다름
→ 각 루프마다:
  - $i$번째 값을 $i+1$번째 값과 비교한다
  - $i$번째 값이 $i+1$번째 값보다 크다면 두 요소의 위치를 교환한다
  - 맨 오른쪽 원소를 (루프의 탐색 범위에서) 제외한다

```
bubbleSort(A[], n)
{
    for last <- n downto 2    {
        for i <- 1 to last - 1    {
            if (A[i] > A[i+1]) then A[i] <-> A[i+1]
        }
    }
}
```
  
시간 복잡도: $T(n) = (n-1) + (n-2) + \cdots + 2 + 1 = \frac{n(n-1)}{2} = O(n^2)$

### 선택 정렬과 버블 정렬의 비교
두 정렬 방식 모두 **비교** 횟수는 각 루프마다 $n-1, n-2, \cdots, 2, 1$번으로 동일함 **그러나:**
- 선택 정렬은 각 루프마다  $1$회의 **교환**이 일어나는 반면, 버블 정렬은 최대 $n-1, n-2, \cdots, 2, 1$회의 교환이 일어날 수 있음
- **대신,** 버블 정렬의 경우엔 주어진 배열이 이미 정렬되었는지 아닌지를 해당 루프에서 **교환이 한번이라도 일어났는지 여부**를 통해 확인이 가능하며, 정렬을 조기 종료 시킬 수 있음. 따라서 버블 정렬의 경우엔 최선의 경우 시간복잡도가 $O(n)$이 됨.
- 선택 정렬은 교환 횟수가 버블 정렬보다 일반적으로 적은 대신, 배열이 이미 정렬되었는지 감지가 불가능하여 어떤 경우에도 $O(n^2)$의 시간복잡도를 가짐.
  
두 정렬 모두 최악의 경우, 시간복잡도는 $O(n^2)$으로 동일하지만, 실제 실행시간을 상수 계수까지 비교해본다면 차이가 발생함.

#### 최악의 경우 연산 횟수 비교 ($n=1000$)

| 구분 | 선택 정렬 | 버블 정렬 | 비율 |
|---|---|---|---|
| **비교 횟수** | $\frac{n(n-1)}{2} = 499,500$ | $\frac{n(n-1)}{2} = 499,500$ | 1:1 |
| **교환 횟수** | $n-1 = 999$ | $\frac{n(n-1)}{2} = 499,500$ | 1:500 |
| **대입 연산** | $3(n-1) = 2,997$ | $\frac{3n(n-1)}{2} = 1,498,500$ | 1:500 |
| **총 연산** | $499,500 + 2,997 \approx 502,000$ | $499,500 + 1,498,500 \approx 2,000,000$ | 1:4 |

### 삽입 정렬 (insertion sort)
각 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.  
(이미 정렬이 된 $k-1$개의 값이 있고, 거기에 하나를 추가하여 $k$개가 정렬되도록 만든다 생각하면 됨)

#### 삽입 위치를 어떻게 정할 것인가?
1. 맨 앞에서 부터 비교를 시작하여, 새로 넣고자하는 요소보다 크거나 같은 값이 나타나면 (혹은 맨 뒤에 도달 할 때 까지) 그 값 앞에 삽입 
2. 맨 뒤에서 부터 비교를 시작하여, 새로 넣고자하는 요소보다 작거나 같은 값이 나타나면 (혹은 맨 앞에 도달 할 때 까지) 그 값 뒤에 삽입  

두 방법이 대칭적인 것으로 동일할 것이라 생각되나, 그렇지 않을 수도 있음:  
**정렬할 데이터가 배열에 저장되어있기 때문에**, 1번 방법의 경우, 새로 추가하는 요소보다 작은 값들과 모두 비교를 해서 삽입할 위치를 찾았어도, 결국 그 위치에 삽입하기 위해선 새 요소보다 큰 값들을 모두 뒤로 한칸씩 밀어줘야하므로 결국 모두 순회하게 됨. 반면, 2번 방법의 경우엔 새 요소보다 작은 값들까지 순회할 필요가 없음. 

*값을 뒤로 한칸씩 밀어야하기 때문에 추가되는 요소가 지워지지 않도록 임시변수에 저장해야 함!*

```
insertionSort(A[], n)  // sort array A[1, ..., n]
{
    for i <- 2 to n    {  --- (1)
        find a correct position in A[1, ..., i] and insert A[i]  --- (2)
    }
}
```
수행시간:  
1. for 루프는 $n-1$번 반복
2. 삽입은 최악의 경우 $i-1$번 비교
→ 최악의 경우 $T(n) = (n-1) + (n-2) + \cdots + 2 + 1 = O(n^2)$
→ 최선의 경우(이미 정렬되어있는 경우)엔 $T(n) = 1 + 1 + \cdots + 1 = n - 1 = O(n)$

약간의 오버헤드까지 고려하면 선택/버블 정렬보다 삽입 정렬이 좀 더 빠르다. 특히, 버블 정렬도 최선의 경우가 $O(n)$ 또는 $n-1$로 동일해보이지만, 버블 정렬은 추가로 교환이 발생했는지 체크(`!(swapped)`) 해야하거나 하는 등의 (아주 미미한) 오버헤드가 있긴 함.
